ウェブフロントエンド開発には多くの悩み所があると思っています。
その中で、私が趣味や業務で開発する際にどのような技術選択をしているか、どのようなところに気を付けているかを自分が知っている範囲でまとめてみようと思います。
自分も手探りで正解が分かっていないところがあるのでアドバイス・反論・指摘などがあれば頂きたいです。

## 言語

ウェブフロントエンドはほぼ TypeScript 一択かなと思っています。TypeScript は JavaScript の厳密な superset と定義されているので better JavaScript としてまず迷わず採用することができます。型が高機能でモダンな言語機能もあり、エディタのサポートもかなり賢いので書き味が非常に良いです。
定義上 JavaScript の superset なので負の遺産も引きずってしまうところはありますが、変なことをしなければ問題にはならないかなと思っています。

Elm のように堅牢性という明確なメリットがあるものであれば使う価値があると思うのですが、正直 TypeScript でも ESLint を厳しくしたりした上で罠を理解していれば実用上安全に書けると思っているので無難かなと思っています。パフォーマンスの都合上どうしても非純粋操作が必要になるなどの場合には port 経由で Elm 外部で JavaScript や TypeScript を使わざるを得ないので、どのみち常に Elm のみを使うということはできませんし、それなら TypeScript をなるべく安全に使えるように整えるのが構成がシンプルで実用上無難かなと思ってしまっています（いや、Elm を使い倒していないので嘘かもしれませんが…）。

## フレームワーク

フレームワーク選択は開発効率をかなり大きく左右すると思います。
私が複数のアプリ実装で 1 年以上使用して使い勝手が分かっているのは React と Angular の二つだけなのですが、この 2 択であれば少なくとも自分は React の方が圧倒的に開発効率面で優れていると感じました。
（ちなみに React はフレームワークというよりライブラリだと言われそうですが、役割的にたびたび比較対象にされるので便宜上フレームワーク比較ということにしています。）

-   React
    -   シンプルかつ柔軟性があり一番気に入っている。以下のようなメリットがあると思っている。
        -   フレームワークというより、TypeScript の上に乗せるライブラリなのでほとんどの部分を JavaScript（TypeScript）の世界に寄せられる点で分かりやすい。
        -   仮想 DOM が何をしているのか概要さえ理解していればほとんどの挙動が推測できる。
        -   stateless なコンポーネントを純粋関数的に書くことができ、記述量も少ないため切り出しコストが少ない。
        -   React hooks によりロジックの抽象化の幅がかなり広く便利。
    -   デメリット
        -   メモ化の手間が多い。さぼるとパフォーマンスが大きく落ちる可能性があるが、それを十分機械的にチェックしきれない（意識的に必要な場所をメモ化しないといけない）。
-   Angular
    -   適切にチューニングした結果出来上がるアプリケーションのパフォーマンスに React と比べて大きな差は無い（と言われているはず）
    -   比較すべきは開発効率だが、主に以下の理由により React と比べてかなり劣ると思っている。
        -   コンポーネント切り出しコストが高い。
            -   コンポーネントを切り出すときに毎回 Module に登録しないといけない。これが面倒なので`ng g` というコマンドを使うという解決策が用意されているがどちらにせよ面倒。React のように普通の関数の切り出しと同じ感覚ではコンポーネント切り出しができないため、手間の問題でコンポーネントが巨大化しやすく、結果としてメンテナンスがしづらくなる。
        -   Module・Directive・Pipe といった特有の（不必要に）複雑な概念を使う必要があるが、それによって得られるメリットがほぼ無い
            -   Angular を使う前提なら使わざるを得ない or メリットが無いわけではないが、React では必要にならないし React で同様のことを実現する場合と比べて優れた解決策とは思えない。
            -   Angular の場合 Directive とは Component の上位概念だが、component だけしか無い方が見通しが良いはずで、なぜそこで自由度を上げてしまったのか分からない。コンポーネント記述コストが高いがために生まれた代物という気がする。
        -   テンプレート記述言語が独特で使いづらい
            -   JavaScript の亜種のような言語で記述する必要があり、学習コストが高い。
            -   async pipe などの複雑な pipe が組み込みで存在し、template の複雑度が高く安全性が低い。挙動の分からないコードを簡単に書けてしまう。
            -   TypeScript の型チェックが一部効かない。

### そのほかのフレームワーク

React が十分使い勝手が良く無難な選択なので、なかなか他のフレームワークに手を出せておらず、詳しいところはよく分かっていませんが一応書いてみます。

-   Vue
    -   人気がありそうだが使用経験が少なくあまり分からない。 React と比べて明確なメリットはなさそうな印象（Angular の派生なイメージなのでそもそも使う気にならない）。
-   [Elm](https://guide.elm-lang.jp/)
    -   強力な静的型付け・デフォルトで immutable であることなどにより実用上ランタイムエラーが出ないという大きなメリットがある。
    -   正直に言うと軽くしか触ったことがないため正確な比較はできない。
    -   JS/TS でできることすべてができるわけではなく、非純粋操作は port で外出しする必要があり、port 使用が増える場合は Elm は不向きと言われている。アプリ全体に採用してしまってよいのか最初に悩みそう。
    -   React のコンポーネントを Elm に置き換えるというスモールスタートな選択肢もあるそうだが、それはそれで構成が複雑になるし見合うメリットがあるのかイマイチ想像できない。
    -   自分一人で書く分には React と TypeScript と厳しめに設定した ESLint 設定で実用上十分安全に書けているので、乗り換える大きなインセンティブが無く、本格的に使うまでに至っていない。（あまり本質的ではないが）記法が独特で個人的にはとっつきづらかったことや UI ライブラリを改めて探すのが面倒という理由もある。
    -   React は（非純粋な処理も含みうる）コンポーネントというリッチなオブジェクトを単位として UI を構築するが、これが複雑さを増やし安全性を損なう原因でもある半面、人間的に考えやすさも生んでいると思っており、うまく使えば開発効率が上がると思っている（慣れに過ぎない可能性はある）。
        -   状態を内包するのが自然なコンポーネントライブラリが欲しいことは結構ある。Elm の場合そういうときは view 関数と reducer のペアを提供するような形になるのだと思うが、コンポーネント 1 個を提供するのと比べるとややインターフェースが分かりづらくなってしまわないのかないう心配があったりする（良く分からない）。
-   [Svelte](https://svelte.dev/)
    -   仮想 DOM のないパフォーマンス重視のフレームワーク。
    -   目的は魅力的だが独自構文が好きでなく一度動かしてみた後はほぼ使っていない。
-   [Solid](https://github.com/ryansolid/solid)
    -   Svelte と同様仮想 DOM を使わないフレームワーク（ライブラリ）でしかも React にかなり似た構文で書けるため興味を持っている。UI ライブラリ等の充実度で React では実現できないレベルのパフォーマンスが要求されるときには採用してみたい。
    -   React の場合パフォーマンス改善のために必要となる `useMemo` などによるキャッシュが不要で構文がさらにシンプルなのが良さそう。

フロントエンド開発においては TypeScript がかなり書きやすいので、なんでもこれで書いてしまいたいという気持ちが自分の場合前提としてあります。そうすると view 構築ツールは React のように TypeScript 上で使えるのライブラリとして導入したくなるのですが、 better React になりうるものは Solid くらいかなと思っているので Solid の周辺がもっと充実したらぜひ使ってみたいと思っています。
正直 React を使っていて自分が不満に思う部分はメモ化のためのコードが多すぎる点くらいなので…。

---

以降は React 前提で書きます。

## 状態管理

SPA の状態管理にはなにかと罠が多く手間も多いと感じており、パフォーマンスを保ちつつバグのないアプリを効率よく作るための技術選定はなかなか難易度が高いと思っています。
現時点の自分の意見としては、堅牢性・柔軟性を重視し、状態管理は React hooks (`useState`, `useReducer`) のみで始めるのが余計なミドルウェアも増えず丸いと思っています。

その上で、

-   Record（Object） や Array の部分更新操作が必要になった場合はアプリ全体のデータ構造を [immutable.js](https://immutable-js.github.io/immutable-js/) に置き換える
-   ある程度複雑な非同期処理がある場合は部分的に [RxJS](https://rxjs-dev.firebaseapp.com/guide/overview) を追加する

が良いと思っています。React で RxJS を採用する例はあまり聞かず、特殊に思われそうな気がしていますが、Observable パターンが強力なのでこれがあれば状態管理はどうとでもなるという意味で技術選択に悩まずに済んで良いのかなと思っています（その代わり書き方・使い方には悩みが生じますが）。
堅牢性だけでなく柔軟性も得たいので、付け外しがしやすいものを好むところはあります。immutable.js はアプリ全体書き換えた方が良くなるので手軽ではないですが、後述のとおりメリットが大きいので必要に応じて採用しています。

---

-   immutable.js について
    -   専用形式を使う必要がある辛さとネイティブオブジェクトと比べた定数倍のオーバーヘッドというデメリットはあるものの、得られる堅牢性と利便性が大きい。
    -   immutable.js の Map や Set の key には primitive 値だけでなく immutable.js の List や Record などのオブジェクトも使えるのがしばしば役に立つ。React でこれを実現するには immutable.js 以外の選択肢を私は知らない。
        -   本質ではないかもしれないが、Set 型に対する集合演算メソッドなど、それぞれのデータ構造に応じたメソッドが組み込み型より充実しているのも便利。
    -   導入するなら API の返り値など外界から来る値を入口ですべて immutable.js 形式にしてしまうのが安全だと思っているが、いちいち全部ラップするのが面倒なのは欠点ではある。しかし、代わりに最初にそこに手間をかけておけば内部は安全になり後は便利だと思うし、その実装コストもそこそこ見積りやすいと思う（Record 型定義の個数分 partial な JS オブジェクトを immutable.js でラップする関数を書けばよいだけ）。
    -   [immer](https://github.com/immerjs/immer)との比較
        -   immer は専用データ形式を強制しない点で手軽さで勝るが、データの部分更新を効率よく行い参照を変える関数を提供してくれるだけではあり、データ自体は通常の mutable な JS オブジェクトではあり使う側が注意しないと破壊的操作ができてしまう点で中途半端な選択ではあると思っている。
        -   破壊的操作は再帰的に `readonly` を付けてしまえば防げるといえば防げるが、その手間を払う時点で手軽さがやや失われているし、 `readonly` 外しもできなくはない。
        -   immutable.js のオブジェクトはデータ構造自体が immutable な操作を強制するので安全性で勝っている。
        -   前述のとおり、immutable.js のデータ構造には専用のメソッドが用意されていたり、Set や Map の key に使える点で便利
-   RxJS について
    -   強力である分扱いが難しいが、ロジックが複雑になってきたらこれを入れればフロントエンドの状態管理・非同期処理はなんでも解決する（気がしている）
        -   RxJS を使えば ngrx のような要領で Redux もどきも多分 Recoil もそう手間をかけずに作れる（やったことはないが）
    -   強力すぎる気もしていて、ある程度慣れていても使い方を誤ると気づきにくいバグを起こしてしまう欠点がある。
        -   そういう意味では、適切に機能を制限したリアクティブプログラミングを実現するツールには意味があると思っている（Recoil とか、内部の動作は違うが React hooks とか）。
        -   使い方を少し誤るとすぐに人の理解できる複雑度を超えてしまうようなところはある気がするので、シンプルさを保つ意識が必要という点ではやはり扱いが難しい。
    -   本当は RxJS よりも性質が良くシンプルなリアクティブプログラミングライブラリがあれば使いたいと思っており、ライブラリを自作したこともある（[Products](./products) ページ参照）が、結局無難に RxJS で済ませていることが多い。
    -   もともと最初に触ったフレームワークが Angular だったので自然に覚えさせられたが、リアクティブプログラミング自体は良いものだと思っていて、React でも必要に応じて採用している。
    -   RxJS 用のいくつかの React hooks を自前で用意して使っている。
-   Redux
    -   RxJS でもやろうと思えば自前で実現できることを、状態の一元管理に目的を絞って機能・API を制限した代物と思っている。
    -   React hooks の `useReducer` と Context で似たようなことが実現できるが、余計な re-render を生じさせないためには工夫が必要になってくる。
        -   個人的には Context は使わずに明示的に`props`で状態をたらい回しするのがシンプルで型チェックもしっかり効いて良いと思っている。しかし、Redux や Context API を使って変更が生じる子孫コンポーネントに直接状態変更を差し込むようなパターンと比べると、`props`たらい回しの途中に通るすべてのコンポーネントで `memo`関数や`useMemo` hooks 等の差分計算オーバーヘッドが生じるため、これが UI に影響するのであればやはり外部状態管理ライブラリは必要になってくるのかな、と思っている。
    -   開発効率の観点から、一定の基準を満たす無害な内部状態はコンポーネントに持たせてもよいと思っており、その観点からも React hooks に寄せてしまうのが良いのかなと思っている。
    -   状態はほぼ中央集権管理で良いと思っているが、
        一定の基準を満たすコンポーネント内部状態を持たせることもアリだと思っているので、柔軟性の点でも単に hooks を使うのが勝ると思っている。
        -   その場合、 props に dispatch 関数や state の一部をたらいまわしするような形になるが、Context で直接子孫に渡すより自分は明示的で良いかと思っている（`memo`などを用いてキャッシュする必要はある）。dispatcher のみ Context で渡してもよいが、いくつかの理由でやや安全性が犠牲になると感じたので基本的に使っていない
        -   状態を中央集権管理すること自体は肯定的だが、子孫コンポーネントが（props を介さずに）それを直接 subscribe するモデルは、コンポーネントが単位になっているのか曖昧な気もしていて自分は好きではない。子孫コンポーネントは props のみに依存して動くようにした方が、テストもしやすいし良いと思っている。

## React でのコーディング

-   コンポーネントの記述
    -   ほとんどは純粋関数コンポーネントにする（言語が TypeScript なので真の純粋関数とは呼べないが）。
    -   必ず `React.memo` で包む（子コンポーネントを持たないよっぽど小さなコンポーネントでない限り）。
        -   差分計算はカスタマイズせずデフォルトの shallow equality で正しく動くようにする。list や record の内部を変更したくなる場合は immutable.js を使う。
    -   props や state に依存する関数はすべて `useCallback` で包み、子コンポーネントの re-render を抑制する。
    -   props や state に依存する変換処理の結果あ非プリミティブ値になる場合は `useMemo` でメモ化する。結果が primitive 値でも計算処理が重い（定数オーダーでない）場合は `useMemo` する。
    -   props や state に依存しない定数・関数はもちろんコンポーネント外に置く。
-   状態管理
    -   React hooks のみで始め、 `useState` か `useReducer` でルートのみに状態を持つ。
    -   非同期処理が複雑になりかけたら RxJS と自作 RxJS hooks （毎回書いてもよいレベルの小さな utility）を import
        -   monorepo 化しているのでローカルなパッケージとして import している
    -   list や record の部分更新が必要なときは immutable.js に全体を置き換える
    -   状態と更新関数は Context API は使わず props で直接たらい回しで渡している。
        -   ここは議論の余地がありそう。私は`value` と `onValueChange` のペアで全部親子間でやりとりすればコンポーネントのインターフェースも明示的で分かりやすいと思っている。
        -   気にすべきはパフォーマンスだが、メモ化を徹底しているのは前提として、Context 越しに子孫コンポーネントが直接 global state を subscribe するパターンと比べると、`memo` の props の差分計算や `useMemo` 等の deps の差分計算のオーバーヘッドは発生してしまうと思われるが、これをどう考えるか次第という問題だと思う。正直毎回コンポーネントツリーが再評価されてメモ化して計算量を抑えるというフレームワークの性質上この程度は仕方ないコストと思ってしまい無視しているので、やはりまずいということであれば知りたい。
    -   props に依存せず外部のコンポーネントの状態に影響しない独立な状態変数であれば、ルートに持ち上げずにコンポーネント内部状態として持っても良いというルールで書いている。
        -   アコーディオンの開閉など、揮発してよい状態
        -   props に依存する状態を持ちたくなる状況では、その対象の props の値自体を状態として扱えるようにする
            -   `props.value` 自体かそれを関数 `f` で変換した結果 `f(props.value)` を state とみなし、dispatch 関数を `(action) => props.onValueChange(g(reducer(state, action)))` のように定義する。ここで `g` は `f` の逆の処理を行う関数。
        -   Context 部分は型が人手になる部分があってあまり好きではない。

## Styling

CSS は [styled-components](https://styled-components.com/) で書き、UI ライブラリに [Blueprint.js](https://blueprintjs.com/) か [Material-UI](https://material-ui.com/) を使っています。正直 CSS の構築にはあまりこだわりはなく悩みもあまり無いので書くことがありません。

## Baas

自分の場合ウェブバックエンドには興味が薄く、なるべく低コストにやってしまいたいので firebase を使っています。
functions で firestore のリスナーや定期実行タスクを TypeScript 関数で簡単に書けるので楽で気に入っています。firebase auth も便利です。
firestore は GraphQL のように型を付けることはできないなどイマイチなところはあるのですが、functions や auth などの他のツール群と組み合わせるときには実質一択になってしまうかなと思っています。
hosting のみ netlify にしていたこともありますが、初期ロードが firebase hosting と比べてかなり遅かったので使うのをやめてしまいました。
