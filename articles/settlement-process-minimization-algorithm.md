---
title: '立替精算の送金回数を最小化する効率の良いアルゴリズム'
emoji: '🐈'
type: 'tech' # tech: 技術記事 / idea: アイデア
topics: ['algorithm']
published: false
---

## 前置き

大人数の複数泊の旅行などでは、宿代・食事代・交通費・観光先での入場料など、様々な支払いが発生します。
それぞれを誰かがまとめて支払っていった場合、イベントの後にはこの立替費を精算する必要があります。すべての支払いを一人がまとめて行っていれば単純ですが、異なるメンバーが支払ったものがある場合、送金の仕方がややこしくなりがちです。
現実的な解決策としては例えば一旦一人がすべての支払いを行った状態になるようにまとめた上でその人に全員が送金するという精算方法を取ることが多そうですが、同じペアについて送金を 2 回行うことになり、送金回数という観点では非効率です。

例えば 3 つの支払い項目があり、A, B, C, D, E の 5 人がそれぞれ使った額と支払いが次のテーブルのようになっていたとします。

|            |      A |      B |     C |     D |     E |
| :--------- | -----: | -----: | ----: | ----: | ----: |
| spending 1 |  13000 |  13000 | 13000 | 13000 | 13000 |
| spending 2 |   7000 |   7000 |  7000 |  7000 |  7000 |
| spending 3 |   1500 |   2500 |  2000 |  1500 |  2000 |
| payment 1  | -65000 |        |       |       |       |
| payment 2  |        | -35000 |       |       |       |
| payment 3  |        |        | -9500 |       |       |
| **total**  | -43500 | -12500 | 12500 | 21500 | 22000 |

`payment N` は `spending N` の支払い分を表しています。
マイナスにしているのはその支払いにより借金額を減らしているという意味です。
`spending 3` のように、食事代など、支払うべき額が人によって異なる場合もあります。
差し引きの借金額は total 行のようになります。

この例の場合、以下のように C,D,E が A, B に支払う 3 回の送金で精算することができます。

|        | A      | B      | C                    | D                    | E                    |
| ------ | ------ | ------ | -------------------- | -------------------- | -------------------- |
| 借金額 | -43500 | -12500 | 12500                | 21500                | 22000                |
|        |        |        | B に 12500 円 支払う | A に 21500 円 支払う | A に 22000 円 支払う |

また、この例では C,D,E が少なくとも 1 回ずつは借金分を誰かに送金しなければならないことから、明らかにこの送金手順が最短になります。

このような債務者から債権者への送金回数の合計が最小になるような送金操作列を計算する、なるべく効率の良いアルゴリズムを与えることが本記事の目標です。

### 問題の定式化

長さ $N$ の整数値配列 $A$ が与えられる．
$A$ は $\sum_{i = 0}^{N-1} A[i] = 0$ を満たす．

配列 $A$，整数 $i$, $j$（$0 \leq i < j < N$）（送金する人とされる人），整数 $M \neq 0$ （送金額）に対して，送金操作 $f(A, (i,j,M))$ を以下の 1~2 で定義する．

1. $A[i] \leftarrow A[i] - M;$
2. $A[j] \leftarrow A[j] + M;$

操作列 $(i_1, j_1, M_1), (i_2, j_2, M_2), \ldots, (i_n, j_n, M_n)$ であって $f(A, (i_1, j_1, M_1)), f(A, (i_2, j_2, M_2)), \ldots, f(A, (i_n, j_n, M_n))$ を連続して適用した結果 $A$ の値がすべて $0$ になっている（$\forall i .(A[i] = 0)$）ようなもののうち、 $n$ が最小のものを一つ求めよ。

### 貪欲アルゴリズム

まず思いつくのが「最大債務者から最大債権者への送金を繰り返す」という貪欲アルゴリズムです。

次の例を考えます。

|    A |    B |   C |   D |   E |
| ---: | ---: | --: | --: | --: |
| -500 | -300 | 100 | 300 | 400 |

これに対し貪欲アルゴリズムを適用すると、

![step1](https://github.com/noshiro-pf/mono/blob/develop/articles/settlement-process-minimization-algorithm/1.png?raw=true =400x)
![step2](https://github.com/noshiro-pf/mono/blob/develop/articles/settlement-process-minimization-algorithm/2.png?raw=true =400x)
![step3](https://github.com/noshiro-pf/mono/blob/develop/articles/settlement-process-minimization-algorithm/3.png?raw=true =400x)
![step4](https://github.com/noshiro-pf/mono/blob/develop/articles/settlement-process-minimization-algorithm/4.png?raw=true =400x)
![step5](https://github.com/noshiro-pf/mono/blob/develop/articles/settlement-process-minimization-algorithm/5.png?raw=true =400x)
![step6](https://github.com/noshiro-pf/mono/blob/develop/articles/settlement-process-minimization-algorithm/6.png?raw=true =400x)

という 3 回の送金で精算が完了します。
テーブルで表すと以下のようになります。

| 送金手順      |    A |    B |   C |   D |   E |
| ------------- | ---: | ---: | --: | --: | --: |
|               | -500 | -300 | 100 | 300 | 400 |
| 1. E->A (400) | -100 | -300 | 100 | 300 |   0 |
| 2. D->B (300) | -100 |    0 | 100 |   0 |   0 |
| 3. C->A (100) |    0 |    0 |   0 |   0 |   0 |

C,D,E の 3 人が借金をしているので明らかにこれが最小の送金回数であり、この例に対しては貪欲アルゴリズムで確かに最適解が得られています。

---

同様に次の例でも試してみます。

|    A |    B |   C |   D |   E |
| ---: | ---: | --: | --: | --: |
| -400 | -300 | 200 | 200 | 300 |

同じように「最大債務者から最大債権者への送金を繰り返す」をやってみると、

| 送金手順      |    A |    B |   C |   D |   E |
| ------------- | ---: | ---: | --: | --: | --: |
|               | -400 | -300 | 200 | 200 | 300 |
| 1. E->A (300) | -100 | -300 | 200 | 200 |   0 |
| 2. C->B (200) | -100 | -100 |   0 | 200 |   0 |
| 3. D->A (100) |    0 | -100 |   0 | 100 |   0 |
| 4. D->B (100) |    0 |    0 |   0 |   0 |   0 |

となり今度は 4 ステップかかりました。

しかし、D が 2 回送金を行っているのが無駄に見えるので、少し工夫して

| 送金手順      |    A |    B |   C |   D |   E |
| ------------- | ---: | ---: | --: | --: | --: |
|               | -400 | -300 | 200 | 200 | 300 |
| 1. E->B (300) | -400 |    0 | 200 | 200 |   0 |
| 2. C->A (200) | -200 |    0 |   0 | 200 |   0 |
| 3. D->A (200) |    0 |    0 |   0 |   0 |   0 |

という手順にすると 1 手少ない 3 ステップでも精算ができます。
貪欲法で計算された手順だと、E の借金 `300` と B の立替費`-300` を相殺するという効率の良い 1 手を選べなかったために余りが生じてしまい、余計に 1 回多く送金が必要になっていました。
つまり、この貪欲法では任意の入力に対して最適解を得ることはできないことが分かります。

### 愚直再帰

計算コストを一旦無視して最適解を得る方法として、愚直に再帰するという方法が考えられます。

1. $n$ 人から送金者を 1 人選ぶ（$n$ 通り） → $i$ とする
2. 残りの $n - 1$ 人から受取る人を 1 人選ぶ（$n - 1$通り） → $j$ とする
3. $i$ から $j$ に $\min( |d(i)| , |d(j)| )$ 円送金する（$d(i)$ は $i$ の借金額）
   - $\min( |d(i)| , |d(j)| )$ ... 一方の借金額がちょうど 0 円になるような額
4. 借金額が 0 円になった人を除く残りの $n - 1$ 人以下について再帰
5. 最小回数のときのインデックスのセット $\{ (i_1, j_1), (i_2, j_2), \ldots (i_N, j_N) \}$ を返す
