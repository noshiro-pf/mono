import { Operator } from './types/Operator';
import { Subscriber } from './types/Subscriber';
import { Subscription } from './types/Subscription';
export declare class RN<T> {
    private static subscriberId;
    private static rnId;
    private static engine;
    private static addTasks;
    private static doTask;
    private static exists;
    private static addAsHeapUniq;
    private static addAsHeap;
    private static removeAsHeap;
    readonly name: string;
    private readonly id;
    private readonly priority;
    private readonly parentsInternal;
    private children;
    private subscribers;
    private state;
    private valueInternal;
    private indexInternal;
    private promiseResolver;
    private promiseRejector;
    constructor(initialValue: T, parents: RN<any>[], name: string);
    get value(): T;
    get index(): number;
    terminate(): void;
    listen(runWithFirstValue: boolean | undefined, onFire: (v: T) => void, onError?: (e?: any) => void, onComplete?: (v: T) => void): Subscription;
    subscribe(onFire: (v: T) => void, onError?: (e?: any) => void, onComplete?: (v: T) => void, runWithFirstValue?: boolean): Subscription;
    subscribe(next: (v: T) => void, error?: (e?: any) => void, complete?: (v: T) => void, runWithFirstValue?: boolean): Subscription;
    subscribe(subscriber: Subscriber<T>): Subscription;
    listenUntil(terminator: RN<void>, runWithFirstValue: boolean | undefined, onFire: (v: T) => void, onError?: (e?: any) => void, onComplete?: (v: T) => void, name?: string): Subscription;
    once(): Promise<T>;
    toPromise(): Promise<T>;
    pipe<A>(op1: Operator<T, A>): RN<A>;
    pipe<A, B>(op1: Operator<T, A>, op2: Operator<A, B>): RN<B>;
    pipe<A, B, C>(op1: Operator<T, A>, op2: Operator<A, B>, op3: Operator<B, C>): RN<C>;
    pipe<A, B, C, D>(op1: Operator<T, A>, op2: Operator<A, B>, op3: Operator<B, C>, op4: Operator<C, D>): RN<D>;
    pipe<A, B, C, D, E>(op1: Operator<T, A>, op2: Operator<A, B>, op3: Operator<B, C>, op4: Operator<C, D>, op5: Operator<D, E>): RN<E>;
    pipe<A, B, C, D, E, F>(op1: Operator<T, A>, op2: Operator<A, B>, op3: Operator<B, C>, op4: Operator<C, D>, op5: Operator<D, E>, op6: Operator<E, F>): RN<F>;
    pipe<A, B, C, D, E, F, G>(op1: Operator<T, A>, op2: Operator<A, B>, op3: Operator<B, C>, op4: Operator<C, D>, op5: Operator<D, E>, op6: Operator<E, F>, op7: Operator<F, G>): RN<G>;
    pipe<A, B, C, D, E, F, G, H>(op1: Operator<T, A>, op2: Operator<A, B>, op3: Operator<B, C>, op4: Operator<C, D>, op5: Operator<D, E>, op6: Operator<E, F>, op7: Operator<F, G>, op8: Operator<G, H>): RN<H>;
    pipe<A, B, C, D, E, F, G, H, I>(op1: Operator<T, A>, op2: Operator<A, B>, op3: Operator<B, C>, op4: Operator<C, D>, op5: Operator<D, E>, op6: Operator<E, F>, op7: Operator<F, G>, op8: Operator<G, H>, op9: Operator<H, I>, ...ops: Operator<any, any>[]): RN<any>;
    auditTime(time: number, name?: string): RN<T>;
    debounce(time: number, name?: string): RN<T>;
    delay(time: number, name?: string): RN<T>;
    filter(initialValue: T, predicate: (srcValue: T, srcIndex: number, index: number) => boolean, name?: string): RN<T>;
    filterByLatest(src: RN<boolean>, name?: string): RN<T>;
    flatMap<U>(fn: (srcValue: T, srcIndex: number, index: number) => RN<U>, name?: string): RN<U>;
    map<U>(fn: (srcValue: T, srcIndex: number, index: number) => U, name?: string): RN<U>;
    mapTo<U>(value: U, name?: string): RN<U>;
    valueIs(value: T, name?: string): RN<boolean>;
    valueIsNot(value: T, name?: string): RN<boolean>;
    pluck<K extends keyof T>(member: K, name?: string): RN<T[K]>;
    get<K extends keyof T>(member: K, name?: string): RN<T[K]>;
    withTimestamp(name?: string): RN<[T, number]>;
    pairwise(initialPrevValue?: T, name?: string): RN<[T, T]>;
    scan<U>(initialValue: U, fn: (state: U, srcValue: T, srcIndex?: number, index?: number) => U, name?: string): RN<U>;
    skip(initialValue: T, skipNum: number, name?: string): RN<T>;
    skipWhile(initialValue: T, predicate: (srcValue: T, srcIndex: number, index: number) => boolean, name?: string): RN<T>;
    skipAlreadyAppeared<K extends keyof T>(key?: K, name?: string): RN<T>;
    skipUnchanged(eq?: (a: T, b: T) => boolean, name?: string): RN<T>;
    startWith(initialValue: T, name?: string): RN<T>;
    switchMap<U>(fn: (srcValue: T, srcIndex: number, index: number) => RN<U>, name?: string): RN<U>;
    take(takeNum: number, name?: string): RN<T>;
    takeWhile(predicate: (srcValue: T, srcIndex: number, index: number) => boolean, name?: string): RN<T>;
    takeUntil(terminator: RN<void>, name?: string): RN<T>;
    terminateBy(terminator: RN<void>, name?: string): RN<T>;
    throttle(time: number, name?: string): RN<T>;
    withDefault(defaultValue: T, name?: string): RN<T>;
    withInitialValue(initialValue: T, name?: string): RN<T>;
    withLatest<U>(src: RN<U>, name?: string): RN<[T, U]>;
    protected get parents(): RN<any>[];
    protected fire(): void;
    protected fireWith(v: T): void;
    protected askIfComplete(): void;
    protected complete(): void;
    protected completeWithError(): void;
    private get isCompleted();
    private addChild;
    private addSubscriber;
    private removeSubscriber;
}
//# sourceMappingURL=RN.d.ts.map