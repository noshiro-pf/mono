# 自己紹介

## 趣味

-   Web アプリケーション開発（大学 3 年生くらいから）
    -   主に React を使ってウェブアプリケーションを作ったり、 discord bot を作ったり。
        → <a href="../products">Products</a>
-   ゲーム
    -   ボードゲーム
        -   好きなゲーム： Dominion、Tzolk'in、Algo など
    -   Splatoon 2
    -   将棋（将棋ウォーズ二段）
    -   麻雀
-   ピアノ（9 歳から、東京大学ピアノの会 OB）

<iframe width="560" height="315" src="https://www.youtube.com/embed/klYr8LiMLlQ" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
<iframe width="560" height="315" src="https://www.youtube.com/embed/HdkvPGr69z0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

## ソフトウェアエンジニアになるまでにやってきたこと

-   大学時代（2012 年 4 月～ 2016 年 3 月）
    -   1 年生
        -   プログラミング自体は大学に入るまではほぼやったことが無く、1 年次に Ruby を使ったアルゴリズムの講義を受けたのが初めてでした。
    -   その後、進学振り分け（東大は進学振り分けというシステムで 3 年生からの進学先を選びます）で理学部生物情報科学科に進学しました。理学部生物情報科学科のカリキュラムは履修する講義の選択の幅が比較的広く、生物系／情報系の講義のうち好きな方を選択できるコマが多かったのですが、自分は情報系の講義の方に興味があったのでほぼすべて情報科学科の講義を選んで受けていました。[情報科学科紹介パンフレット](https://www.is.s.u-tokyo.ac.jp/pamph/pdf/utokyo_ISguide2021_all.pdf) の 3 ページ目にあるものだと 「情報数学」、「アルゴリズムとデータ構造」、「形式言語理論」、「計算機システム」、「離散数学」、「情報論理」、「計算量理論」、「連続系アルゴリズム」、「知能システム論」、「言語モデル論」 の講義を（2 年生後半～ 4 年生前半にかけて）受けていました（一部は生物情報科学科の必修とコマが重複していて受けられなかった）。特に好きだったのは「形式言語理論」と「情報論理」でした。
    -   2 年生
        -   2 年生後半の情報科学科と合同の必修の演習では C、Scheme、PowerPC のアセンブリ言語を学びました。この頃から日常的にプログラミングを行うようになりました。
    -   3 年生
        -   演習で C++ を教わり、課題で使うようになりました。
        -   演習課題ではなかったのですが、C++について調べているうちに class や演算子オーバーロードなどの機能を知り、これらを使って行列・ベクトル演算ライブラリを趣味で作って遊んだりしていました。
        -   CUI のプログラムしかそれまで実装してこなかったので GUI アプリケーションの作り方にも興味を持ち始めていました。最初は何から始めればよいのか全く分かりませんでしたが、ちょうどそのころサークルの仲間と毎週末遊んでいたボードゲームの成績表を管理するアプリが欲しいと思っていたので、無料レンタルサーバーを借りて趣味で PHP でこれを作り始めました。その後少しずつ動的な画面要素を足すために JavaScript も使い始めました。
    -   4 年生（卒業研究）
        -   **ZDD** と呼ばれるデータ構造を用いて RNA の二次構造の集合を効率良く表現し、頻出構造のマイニングを行う手法についてのテーマを頂き、研究を行いました。
        -   ZDD について： https://www.jstage.jst.go.jp/article/essfr/4/3/4_3_224/_pdf
        -   ZDD は組み合わせ集合を計算機の主記憶上に効率よく表現することが可能なデータ構造であり、これを用いて生物の RNA の「二次構造」と呼ばれる構造として考えられる膨大な確率付きの組み合わせ集合をメモリ上に効率よく構築することができそう、というアイデアの研究です。
            それまでも最も確率の高い二次構造を計算して調べるということはよく行われていたのですが、実際には一定以上の確率で 2 通り以上の二次構造を取る RNA も存在するため、頻出構造を上手く発見してより精度良く機能推定できるようにすることが目的です。
        -   手法としては、頻出する構造を LCM（Linear time Closed itemset Miner）と呼ばれるデータマイニングアルゴリズムを ZDD 用に独自に改造したもので列挙しました。
        -   ZDD の実装としてこの研究に使いやすい公開ライブラリが見つからなかったため、この研究用に改造することも見据えてフルスクラッチで ZDD を再実装することにしました。
            実装方法の詳細について論文等から読み取れない箇所があったため、
            ちょうど ZDD を扱う研究をされていた工学系研究科の助教の方に詳細を聞きに行き、
            それを元にゼロから実装しました（最終的なコード量は 3000 行程度）。
        -   組み合わせ集合の表現方法として ZDD を使った場合、集合の等価性判定が `O(1)` でできたり、union や intersection などを取る集合演算を効率良く行うことができるのですが、これを使うと **LCM アルゴリズムの効率改善が可能であるというアイデア**が浮かび、実際に C++ で実装してパフォーマンスの計算実験も行った結果で卒業論文を書きました。
        -   重い処理なのでメモリ効率やキャッシュ効率を上げるための実装レベルの工夫をするため C++ で実装しました。
-   大学院（修士）時代（2016 年 4 月～ 2018 年 3 月）
    -   院進学先として生物情報科学科の研究室と迷いつつも、生物学自体には興味がなくなってしまっていたので、特にそれを目的としなくてもよいアルゴリズムの研究がしたいと思い、修士から研究室を変えて新しい研究テーマに取り組み始めました。
        -   **「警邏問題」**(patrolling problem)と呼ばれる離散数学の問題の、ある設定における計算量クラスを調べる理論研究についてのテーマを頂き、多項式時間アルゴリズムの構成や NP 困難性の証明に取り組みました。
    -   研究を進めていく中で、純粋な理論の研究には能力・興味共に自分にはあまり向いていないのではないかと M1 の段階で感じるようになってしまい、卒論で取り組んでいたような応用的なテーマでのアルゴリズム改善や、プログラミング自体の方が自分にとっては向いているのでは、と途中から考えるようになりました。
        その後研究テーマをさらに変えることも可能なのかも少し考えましたがあまり良いアイデアが無く、また研究のためにプログラムを書いていた卒論の頃にも、研究の場ではエンジニアリング自体はあまり評価されない雰囲気も感じたので（当時そう思ったというだけで実際にそうなのかは定かではありませんが）、**プログラミング自体が評価される環境は何か**ということを軸として今後のキャリアを考えた結果、ソフトウェアエンジニアとして就職するという進路を選ぶことにしました。
    -   一方この頃、卒論研究と違って修論のテーマではプログラミングは必要なくなってしまったので、趣味の自主開発も再開しており、この頃は余暇にひたすらボードゲーム「Dominion」のオンライン対戦アプリを JavaScript で作っていました。
        -   当時の JavaScript はギリギリ ES6 の機能がブラウザ実装が完了していない時代でした。当時の自分は Babel や tsc などの transpiler という道具を知らなかったので、 function を使って class を模倣する方法を調べたり（「[Google 流 JavaScript におけるクラス定義の実現方法(ES6 以前)](https://www.yunabe.jp/docs/javascript_class_in_google.html)」）、generator と Promise を使って async function を実装したりして対応していました。
        -   当時の自分は生の JS の API や jQuery を使う方法くらいしか知らなかったので、ゲームの状態に応じて命令的に画面を更新するコードを書いていました。
            今でこそ React のような**宣言的 UI**を簡単に実現するライブラリ・フレームワークがたくさん存在しますが、当時はそれらを知らなかったので、状態管理には非常に悩みました。
            画面を state と同期させるために、DOM 更新と state 更新を同時に行う関数をいくつも作ったりしていましたが、あまりこれを細かくし過ぎると DOM 操作の効率が悪くなってしまう（特定の DOM に対する一連の操作は差分をまとめて適用した方が速い）ため、その粒度にも制約があり非常に実装しづらかったのを覚えています（DOM 操作のパフォーマンスとコードの簡潔性がトレードオフになってしまっていた）。
        -   後で存在を知った React は、まさにこのとき自分が抱えていた課題を解決するうってつけのツールでした。そのときすぐにその価値が分かったのは先述のような課題を前もって持っていたからだったので、新しいツールを導入する際は**今本質的に何が問題となっているのか**をよく分析し理解してから行うのが重要だと考えるようになりました（もちろん「幅広くとりあえず触ってみる」ことも大事だとは思うのですが、今具体的に課題が存在するのであればそれをベースに探し求めていく方が、最終的には最適な道具を見つけてそれを使いこなせるようになるまでにかかる時間は早いのではないかと考えています）。
        -   基本的なカードセットで複数人で実際にオンラインプレイできる状態まで実装し、友人と何度か遊んでいました。コード量は合計 1~2 万行程度。
    -   就活中に発見したある企業のハンズオンイベントで、Angular の基本的な使い方を教わりました。それ以降、既存のアプリも Angular に移植したり、新規に日程調整アプリ（「調整さん」のような UI でイベント日程調整を行うためのアプリ）の初期版などを作っていました。
-   会社員時代（2018 年 4 月 ～ 現在）
    -   NTT 研究所（2018 年 4 月 ～ 2019 年 3 月）
        -   就活ではウェブ企業を含め何社か内定を貰ったのですが、新卒でベンチャー企業に行く選択に自信が持てず、NTT 研究所に就職することになりました。
        -   入社後 5 月～ 7 月の 3 か月間は実務研修として NTT レゾナント株式会社に他同期 2 名と一緒に配属となり、自分はインフラ部署へ配属となりました。
            -   ① 社内の各サービス担当部署のサーバー使用料を課金するシステムを OpenStack 上の VM に構築（Apache を入れるところから）・運用、②Cloud Foundry 上に新規サービスを追加する際のインフラ作業の自動化（スクリプト化による自動化、業務委託先への手順の整備）、③ オンプレミスサーバーのセットアップ（サーバーラックに設置して光ファイバーなどの配線を行うなど）、などを行いました。
        -   8 月には研究所に戻り、先輩社員の指導の下、機械学習モデルの圧縮というテーマを貰い、論文・実験調査することになりました。
            -   まずは紹介された「[ゼロから作る Deep Learning ―Python で学ぶディープラーニングの理論と実装](https://www.amazon.co.jp/%E3%82%BC%E3%83%AD%E3%81%8B%E3%82%89%E4%BD%9C%E3%82%8BDeep-Learning-%E2%80%95Python%E3%81%A7%E5%AD%A6%E3%81%B6%E3%83%87%E3%82%A3%E3%83%BC%E3%83%97%E3%83%A9%E3%83%BC%E3%83%8B%E3%83%B3%E3%82%B0%E3%81%AE%E7%90%86%E8%AB%96%E3%81%A8%E5%AE%9F%E8%A3%85-%E6%96%8E%E8%97%A4-%E5%BA%B7%E6%AF%85/dp/4873117585)」という本で畳み込みニューラルネットワークの実装について勉強しました。
                -   Python で写経するだけでも良かったのですが、自分がプログラミング関連の勉強で写経というものが好きではなかったので、せっかくだから別言語で実装してみようということで（業務外時間も使いつつ） TypeScript でこの本に出てくる 3 層畳み込みニューラルネットワークを（推論実行の forward 処理だけ）実装しました。
                    -   手書き数字認識アプリ「[MNIST App](https://tools-8af31.firebaseapp.com/#/toybox/mnist)」（Angular と TypeScript で実装。しばらくメンテしていないので動作保証はできません）
                    -   [ソースコード](https://github.com/noshiro-pf/mono/tree/main/experimental/angular_projects/projects/MNIST-dev)
                        -   元コードが numpy に依存していたので TypeScript でも同等のライブラリが必要だったのですが、せっかくなので DNN 自体はライブラリゼロで自分で全部実装してやろうということで、使用されていた numpy の多次元配列操作関数などを全部再実装しました。全体的に、正しく動けば良いというつもりでパフォーマンスはあまり気にせず作ったので速くはありません。
            -   その後、モデル圧縮の手法についてサーベイを行いました。
                -   Deep Neural Network モデルは数百 MB ものサイズになる場合があるので、このモデル圧縮をするとメモリ使用量を大幅に減らすことでエッジデバイスに搭載できるようにしたり、消費電力を減らすことができます。
                -   モデル圧縮の手法には、枝刈り、量子化、低ランク近似、蒸留など様々あるのですが、どれも圧縮する過程に技術的難しさがあったり、推論精度・実行速度・メモリ使用量のいずれかが犠牲になるトレードオフがあり、すべての良いとこ取りをするのは難しいようでした。自分はまず「[Deep Compression](https://arxiv.org/abs/1510.00149)」（動画： https://www.youtube.com/watch?v=xDS7ljg0T-E ）という論文をベースに調査を進めていたのですが、この論文が対象としていたモデルアーキテクチャが VGG-16 という少し古いものであり、圧縮率に大きく寄与しているのは全結合層であったことから、ResNet などの畳み込み層が多いアーキテクチャのモデルに対する圧縮効率の良い手法が無いか調査・検討していました。
    -   LeapMind（2019 年 4 月 ～ 2020 年 10 月）
        -   諸事情あり NTT 研究所から転職。前職でモデル圧縮について研究している中で、実用化する上でほぼトレードオフの推論精度・実行速度・メモリ使用量のどれがどの程度重視されるのかを知りたいと思っていたのですが、実際に実用化を目指している会社があるということが目に留まり応募、入社しました。
        -   前職で学んだディープラーニングモデルについての知識も生かしつつ、自分はウェブフロントエンドエンジニアとしてアプリケーション開発を行いました。使用されていたのが React だったので、入社前に 1 か月ほど触って覚えてから入社しました。
        -   在職中最も長い時間取り組んだのが、アノテーション UI のための React コンポーネントライブラリ開発・メンテナンスで、[このデモアプリ](https://annotation-tool-d8b49.web.app/) に似た矩形を描画・編集できる UI を実現するためコンポーネントをフルスクラッチ実装しました。
            -   複数のプロジェクトで使用する予定があり、画像部分は画像でも動画でも動く必要があったり、ズームや undo/redo にも対応することを考えて作る必要があったので、インターフェース・状態管理の仕様が複雑で上手く整理するのに苦労しました。
    -   Kabuku（2020 年 11 月 ～ 現在）
        -   加筆予定

### 主要な自主制作物

1. **「日程調整アプリ」** (https://event-schedule-app.web.app/)
    - これまで作ったものの中で最も長く機能開発・メンテナンスしてきた実用アプリ。
    - 2017 年頃に Angular で初期バージョンを実装したが、Angular が使いづらいことも原因でバグが多かったため、2020 年頃に React に移植。その後、現在に至るまで、メール通知などの便利なオプション機能を不定期で追加しつつメンテナンスしています。
        - 2022 年時点のバージョンでは、状態管理に自作ライブラリ「SyncFlow」を用いて実装している。それ以外のルーティングや immutable collection 操作（immer.js でやるような処理）などにも自作ライブラリを使用しています（そのうち React も自作して全部自作ライブラリに置き換えてみたい…）。
    - **紹介ページ → 「[日程調整アプリの紹介](https://noshiro.notion.site/899268cf44c54eefa564543c63864f2a)」**
2. **「SyncFlow」**
    - RxJS を意識した非同期ストリーム処理ライブラリ（Observable）
    - RxJS と比べて余計な API や hot/cold Observable の違いなどの複雑さの要因になっている仕様をそぎ落とし、尚且つ RxJS で発生する「Glitch」と呼ばれる不健全な挙動が発生しないような内部実装を発案しゼロから自作しました。
    - **紹介ページ → 「[リアクティブプログラミングライブラリを自作した話](https://docs.google.com/presentation/d/1y9F5jxD6e1bFzLOs3BVAzIqhW806OfmLzIYaaU1j7yM/edit#slide=id.p)」**
        - 既存のライブラリやリアクティブプログラミングに関する論文をサーベイし、仕様を決めて自作しました。
    - npm package として公開しています。
        - https://www.npmjs.com/package/@noshiro/syncflow
        - ドキュメントを作ろうと思い始めて幾星霜…
    - 専用 React hooks も用意しています。これを使うと Recoil に似たような使用感の状態管理ライブラリとして使用することができます。
        - https://www.npmjs.com/package/@noshiro/syncflow-react-hooks
        - https://www.npmjs.com/package/@noshiro/syncflow-preact-hooks
    - ソースコード： https://github.com/noshiro-pf/mono/tree/main/packages/utils/syncflow

これ以外の細々したものは「制作物」ページにまとめています。

## スキル・価値観・考え方

### 得意なこと・今後やっていきたいこと

1. 賢い GUI アプリケーションを作って問題解決すること
    - なぜ "GUI" にこだわるのか？
        - 様々なタスクを行う際の認知負荷を下げる効果が大きいと考えているから。
        - 良い GUI は既存のタスクを簡単にし、人間がより難しいタスクにリソースを使えるようになるから。
        - 優れた GUI を設計するのは難しくてやりがいのある仕事だから
        - 人間が直接触れる部分である → 人間が良い UI とは何か考え続けなければならない （機械的に導ける唯一解があるようなものではなさそう）
        - 様々な人間がいて、認知特性もそれぞれ異なるということも考慮しなければならず難しい
2. 実装難易度の高いアプリケーションを高品質に実装すること
    - 自分以外の専門分野を持つ人とも協力し、自分一人では実現しづらい高度なアプリケーションを作りたい。
    - 難易度の高い GUI の実装に興味があります。
    - 既存のライブラリ・ツールを簡単に組み合わせるだけでは解決できないような重実装が必要なアプリケーション開発などができると嬉しいです。
    - 複雑なロジックを綺麗に整理するのが好きです。
    - 基本的なアルゴリズムやデータ構造を適切に選び、実行効率を意識したコードを書くことができます。
    - （親しみのある分野であれば）論文実装等を含むアルゴリズムの実装もできます。
3. ウェブ（フロントエンド）のより優れた実装設計を追求すること
    - どういう設計をするとより速く正確に作りたいものを高品質に実装できるのか、また作り続けられるのかをゼロから考えたい。
        - 状態管理ライブラリを自作しているのもそのため。
    - 堅牢で可読性の高いプログラムを書くことは重要
        - 型付けを頑張るのは好き
        - 堅く実装することでむしろ速く実装できるようになると考えています。

### できること

-   TypeScript・ウェブフロントエンド周り
    -   なるべく堅牢なコードを効率よく書くため、TypeScript の新しい型機能などを普段から積極的に使っています。複雑な仕様であっても可能な限り正確に型で表現するようにしています。
    -   TypeScript に関数型言語由来の道具も適宜使って堅牢かつ可読性の高いコードを書くことは心掛けています。
    -   優れた UI を考えることに興味があります。綺麗で使いやすいウェブアプリケーションの UI を独力でデザインすることができます。
    -   React でパフォーマンスと堅牢性を意識した実装が得意です。
    -   昔はライブラリ無しの JavaScript のみでそこそこ複雑なゲームを実装したりして苦労したこともあるので、宣言的 UI の構築を実現する React 等のライブラリがどのように有効であるかを比較・理解して使うことができます。
    -   Reactive Programming がどのような点で有用なのかを理解して使用することができます。またその代表的なライブラリとして、RxJS を使ったコードの読み書きができます。
    -   RxJS 風の Reactive Programming ライブラリ「SyncFlow」を自作したことがあります。そのため、RxJS の内部の挙動については大体の場面で類推が効くので、デバッグやパフォーマンスチューニングに役立てることができます。趣味のアプリ開発ではこの「SyncFlow」を用いることで開発効率を高めています。
    -   複雑な非同期処理のロジックを正確に実装することが得意です。
    -   ウェブフロントエンドの状態管理ノウハウがあります。アプリケーションの規模や特性に応じた技術選択ができます。
        -   Elm のような React より厳格なフレームワークと比較したときの React の柔軟性と便利さも重要だと思っています。
            基本的に中央集権管理しつつもコンポーネント内部状態も有効な場面では使うことで React のメリットを最大限引き出せる設計を目指しています。
        -   直近開発した趣味開発の React／Preact アプリでは、自作ライブラリ「SyncFlow」と専用 React hooks を用いて実装しています。 Recoil に似た開発体験だと思います。
    -   React 上で WebGL ライブラリ Pixi.js を使ってキャンバス操作を高速化した矩形アノテーションツールを作ったことがあります（VDom に頼らない状態管理を実装したりしました）。 （→ <a href="../products">Products</a> の「アノテーションツール」）
    -   yarn workspaces を使った mono repo の開発環境構築ノウハウがあります。
        -   Node.js 環境・ブラウザ環境両方に対応した TypeScript ライブラリを作り、普段からメンテしています。
        -   webpack config を TypeScript で書いて運用しています。
        -   CI: 趣味開発では TypeScript のコードはほぼすべて[mono repo](https://github.com/noshiro-pf/mono)で管理しています。このレポジトリ内では GitHub Actions を用いてすべてのパッケージで build, lint, test を走らせるようにしています。
    -   git: 普段から趣味開発でも業務でもコミットを整理して見やすい PR ・ history を作ることを心がけています。
-   そのほかの言語などの経験
    -   大学時代は C++ をメインで書いていて、可読性を犠牲にしない範囲でメモリ使用効率や定数倍高速化を追求するのが好きでした。
        -   大学の卒論では [ZDD](https://en.wikipedia.org/wiki/Zero-suppressed_decision_diagram) と呼ばれるデータ構造を改造したものを C++でフルスクラッチ実装（数千行程度）して実験に使用したりしていました。当時使ったバージョンは C++11 だったと思います。
    -   大学の実習で PowerPC のアセンブリを書いたことはあります。
    -   Rust は少しだけ書けます（TypeScript, C++ ほど慣れてはいません）
    -   Python は必要に応じて書けますが、あまり選びたい選択肢ではありません。業務で簡単な画像処理や小さなウェブバックエンド実装などに使用したことがあります。
-   業務における他の経験
    -   仕様を整理したり不備を発見することは割と得意だと思っています。ユーザー課題・要件から使いやすい UI を考え提案することもできます。
    -   ドキュメンテーションは非常に大事だと考えており、ドキュメントはなるべく論理的に・明確に・かっちり書くことを重視しています。
        -   細かいところだと、文書の誤字・脱字や曖昧な言葉遣いに気づいて指摘 or 修正するということも人より得意な気がします（よくそういう指摘をしていたので）。

### 苦手なこと・やりたくないこと

-   事務作業
-   ミスをシステマティックに防げない作業（注意力に頼る割合が多い作業）
-   朝型生活
-   使いづらい開発環境を使い続けること

### 自分の性格・価値観

-   人と異なることをやりたい
-   大きな課題に長期間じっくり取り組みたい
-   ミスはシステマティックに防ぐべきであると考えている（人間はミスをするという前提で考えている）
-   「安全」は高くつくと考えている（≒ 安く済ませようとすると失敗しやすい）
-   職人的（と良く言われる）
-   最適解を追求するのが好きだが、現実解も考える

## 職について

### どういう仕事がしたいか、どういう環境で働きたいか

-   プロダクト
    -   何らかの形で（日本）社会の課題を解決したい
    -   自分が作るべきだと思えるサービスの開発に携わりたい
    -   自分が使いたくなるサービスを作りたい
-   人
    -   多くの気づきが得られる環境に身を置きたい
        -   ⇔ 既知の局面しか現れない
    -   文化的に馴染みやすい人的環境で働きたい
    -   優秀なメンバーと共に高度な仕事がしたい
        -   自分の持っていないスキル・視点を持つ人と協力して、より高度な仕事をしたい
-   開発
    -   持続可能なプロダクト開発、リファクタリングへの理解がある環境で働きたい
        -   「[エンジニア歴 17 年の俺が、事業系の開発タスクをバンバン投げてくる非エンジニアに、保守の必要性を死ぬほど分かりやすく説明する。](https://note.com/gonjyu/n/nd7bf3efa0728)」
    -   問題解決の方法を 0 から考え直し、仕組みを作って改善する文化がある（≒ 既存の方法に囚われ過ぎない）

## 開発環境

-   OS
    -   **Windows**（開発は WSL）
    -   macOS（2 年くらい使っていた時期はある）
    -   Linux
-   マシン
    -   デスクトップ PC（2022 年 5 月に購入）
        -   Windows 11
        -   RAM 64GB
        -   12th Gen Intel(R) Core(TM) i7-12700 2.10 GHz
    -   ThinkPad X1 Extreme
        -   Windows 11
-   エディタ
    -   **VSCode**
    -   Sublime Text（VSCode の前に使っていた）
    -   vi（サーバーサイドでちょっと書き換えるときとか）
    -   (Emacs)
